{
  "version": "v1",
  "baseUrl": "https://monitoring.googleapis.com/",
  "kind": "discovery#restDescription",
  "description": "Manages your Stackdriver Monitoring data and configurations. Most projects must be associated with a Stackdriver account, with a few exceptions as noted on the individual method pages. The table entries below are presented in alphabetical order, not in order of common use. For explanations of the concepts found in the table entries, read the Stackdriver Monitoring documentation.",
  "servicePath": "",
  "basePath": "",
  "id": "monitoring:v1",
  "documentationLink": "https://cloud.google.com/monitoring/api/",
  "revision": "20191216",
  "discoveryVersion": "v1",
  "version_module": true,
  "schemas": {
    "Type": {
      "type": "object",
      "properties": {
        "sourceContext": {
          "description": "The source context.",
          "$ref": "SourceContext"
        },
        "syntax": {
          "enum": [
            "SYNTAX_PROTO2",
            "SYNTAX_PROTO3"
          ],
          "description": "The source syntax.",
          "type": "string",
          "enumDescriptions": [
            "Syntax proto2.",
            "Syntax proto3."
          ]
        },
        "options": {
          "description": "The protocol buffer options.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        },
        "fields": {
          "type": "array",
          "items": {
            "$ref": "Field"
          },
          "description": "The list of fields."
        },
        "name": {
          "description": "The fully qualified message name.",
          "type": "string"
        },
        "oneofs": {
          "description": "The list of types appearing in oneof definitions in this type.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "id": "Type",
      "description": "A protocol buffer message type."
    },
    "RowLayout": {
      "type": "object",
      "properties": {
        "rows": {
          "type": "array",
          "items": {
            "$ref": "Row"
          },
          "description": "The rows of content to display."
        }
      },
      "id": "RowLayout",
      "description": "A simplified layout that divides the available space into rows and arranges a set of widgets horizontally in each row."
    },
    "Column": {
      "description": "Defines the layout properties and content for a column.",
      "type": "object",
      "properties": {
        "widgets": {
          "type": "array",
          "items": {
            "$ref": "Widget"
          },
          "description": "The display widgets arranged vertically in this column."
        },
        "weight": {
          "description": "The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering.",
          "format": "int64",
          "type": "string"
        }
      },
      "id": "Column"
    },
    "Text": {
      "description": "A widget that displays textual content.",
      "type": "object",
      "properties": {
        "format": {
          "description": "How the text content is formatted.",
          "type": "string",
          "enumDescriptions": [
            "Format is unspecified. Defaults to MARKDOWN.",
            "The text contains Markdown formatting.",
            "The text contains no special formatting."
          ],
          "enum": [
            "FORMAT_UNSPECIFIED",
            "MARKDOWN",
            "RAW"
          ]
        },
        "content": {
          "type": "string",
          "description": "The text content to be displayed."
        }
      },
      "id": "Text"
    },
    "Threshold": {
      "description": "Defines a threshold for categorizing time series values.",
      "type": "object",
      "properties": {
        "label": {
          "type": "string",
          "description": "A label for the threshold."
        },
        "value": {
          "description": "The value of the threshold. The value should be defined in the native scale of the metric.",
          "format": "double",
          "type": "number"
        },
        "direction": {
          "enumDescriptions": [
            "Not allowed in well-formed requests.",
            "The threshold will be considered crossed if the actual value is above the threshold value.",
            "The threshold will be considered crossed if the actual value is below the threshold value."
          ],
          "enum": [
            "DIRECTION_UNSPECIFIED",
            "ABOVE",
            "BELOW"
          ],
          "description": "The direction for the current threshold. Direction is not allowed in a XyChart.",
          "type": "string"
        },
        "color": {
          "type": "string",
          "enumDescriptions": [
            "Color is unspecified. Not allowed in well-formed requests.",
            "Crossing the threshold is \"concerning\" behavior.",
            "Crossing the threshold is \"emergency\" behavior."
          ],
          "enum": [
            "COLOR_UNSPECIFIED",
            "YELLOW",
            "RED"
          ],
          "description": "The state color for this threshold. Color is not allowed in a XyChart."
        }
      },
      "id": "Threshold"
    },
    "GridLayout": {
      "id": "GridLayout",
      "description": "A basic layout divides the available space into vertical columns of equal width and arranges a list of widgets using a row-first strategy.",
      "type": "object",
      "properties": {
        "widgets": {
          "description": "The informational elements that are arranged into the columns row-first.",
          "type": "array",
          "items": {
            "$ref": "Widget"
          }
        },
        "columns": {
          "type": "string",
          "description": "The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering.",
          "format": "int64"
        }
      }
    },
    "SourceContext": {
      "id": "SourceContext",
      "description": "SourceContext represents information about the source of a protobuf element, like the file in which it is defined.",
      "type": "object",
      "properties": {
        "fileName": {
          "type": "string",
          "description": "The path-qualified name of the .proto file that contained the associated protobuf element. For example: \"google/protobuf/source_context.proto\"."
        }
      }
    },
    "Row": {
      "description": "Defines the layout properties and content for a row.",
      "type": "object",
      "properties": {
        "widgets": {
          "type": "array",
          "items": {
            "$ref": "Widget"
          },
          "description": "The display widgets arranged horizontally in this row."
        },
        "weight": {
          "description": "The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering.",
          "format": "int64",
          "type": "string"
        }
      },
      "id": "Row"
    },
    "PickTimeSeriesFilter": {
      "type": "object",
      "properties": {
        "direction": {
          "enum": [
            "DIRECTION_UNSPECIFIED",
            "TOP",
            "BOTTOM"
          ],
          "description": "How to use the ranking to select time series that pass through the filter.",
          "type": "string",
          "enumDescriptions": [
            "Not allowed in well-formed requests.",
            "Pass the highest ranking inputs.",
            "Pass the lowest ranking inputs."
          ]
        },
        "rankingMethod": {
          "enum": [
            "METHOD_UNSPECIFIED",
            "METHOD_MEAN",
            "METHOD_MAX",
            "METHOD_MIN",
            "METHOD_SUM",
            "METHOD_LATEST"
          ],
          "description": "rankingMethod is applied to each time series independently to produce the value which will be used to compare the time series to other time series.",
          "type": "string",
          "enumDescriptions": [
            "Not allowed in well-formed requests.",
            "Select the mean of all values.",
            "Select the maximum value.",
            "Select the minimum value.",
            "Compute the sum of all values.",
            "Select the most recent value."
          ]
        },
        "numTimeSeries": {
          "description": "How many time series to return.",
          "format": "int32",
          "type": "integer"
        }
      },
      "id": "PickTimeSeriesFilter",
      "description": "Describes a ranking-based time series filter. Each input time series is ranked with an aligner. The filter lets through up to num_time_series time series, selecting them based on the relative ranking."
    },
    "DroppedLabels": {
      "type": "object",
      "properties": {
        "label": {
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map from label to its value, for all labels dropped in any aggregation.",
          "type": "object"
        }
      },
      "id": "DroppedLabels",
      "description": "A set of (label, value) pairs which were dropped during aggregation, attached to google.api.Distribution.Exemplars in google.api.Distribution values during aggregation.These values are used in combination with the label values that remain on the aggregated Distribution timeseries to construct the full label set for the exemplar values. The resulting full label set may be used to identify the specific task/job/instance (for example) which may be contributing to a long-tail, while allowing the storage savings of only storing aggregated distribution values for a large group.Note that there are no guarantees on ordering of the labels from exemplar-to-exemplar and from distribution-to-distribution in the same stream, and there may be duplicates. It is up to clients to resolve any ambiguities."
    },
    "SpanContext": {
      "description": "The context of a span, attached to google.api.Distribution.Exemplars in google.api.Distribution values during aggregation.It contains the name of a span with format:  projects/PROJECT_ID/traces/TRACE_ID/spans/SPAN_ID",
      "type": "object",
      "properties": {
        "spanName": {
          "description": "The resource name of the span in the following format:\nprojects/[PROJECT_ID]/traces/[TRACE_ID]/spans/[SPAN_ID]\nTRACE_ID is a unique identifier for a trace within a project; it is a 32-character hexadecimal encoding of a 16-byte array.SPAN_ID is a unique identifier for a span within a trace; it is a 16-character hexadecimal encoding of an 8-byte array.",
          "type": "string"
        }
      },
      "id": "SpanContext"
    },
    "XyChart": {
      "description": "A chart that displays data on a 2D (X and Y axes) plane.",
      "type": "object",
      "properties": {
        "dataSets": {
          "type": "array",
          "items": {
            "$ref": "DataSet"
          },
          "description": "The data displayed in this chart."
        },
        "yAxis": {
          "$ref": "Axis",
          "description": "The properties applied to the Y axis."
        },
        "thresholds": {
          "description": "Threshold lines drawn horizontally across the chart.",
          "type": "array",
          "items": {
            "$ref": "Threshold"
          }
        },
        "chartOptions": {
          "description": "Display options for the chart.",
          "$ref": "ChartOptions"
        },
        "timeshiftDuration": {
          "description": "The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type.",
          "format": "google-duration",
          "type": "string"
        },
        "xAxis": {
          "$ref": "Axis",
          "description": "The properties applied to the X axis."
        }
      },
      "id": "XyChart"
    },
    "ChartOptions": {
      "type": "object",
      "properties": {
        "mode": {
          "enum": [
            "MODE_UNSPECIFIED",
            "COLOR",
            "X_RAY",
            "STATS"
          ],
          "description": "The chart mode.",
          "type": "string",
          "enumDescriptions": [
            "Mode is unspecified. The view will default to COLOR.",
            "The chart distinguishes data series using different color. Line colors may get reused when there are many lines in the chart.",
            "The chart uses the Stackdriver x-ray mode, in which each data set is plotted using the same semi-transparent color.",
            "The chart displays statistics such as average, median, 95th percentile, and more."
          ]
        }
      },
      "id": "ChartOptions",
      "description": "Options to control visual rendering of a chart."
    },
    "DataSet": {
      "description": "Groups a time series query definition with charting options.",
      "type": "object",
      "properties": {
        "timeSeriesQuery": {
          "$ref": "TimeSeriesQuery",
          "description": "Fields for querying time series data from the Stackdriver metrics API."
        },
        "minAlignmentPeriod": {
          "type": "string",
          "description": "Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals.",
          "format": "google-duration"
        },
        "plotType": {
          "type": "string",
          "enumDescriptions": [
            "Plot type is unspecified. The view will default to LINE.",
            "The data is plotted as a set of lines (one line per series).",
            "The data is plotted as a set of filled areas (one area per series), with the areas stacked vertically (the base of each area is the top of its predecessor, and the base of the first area is the X axis). Since the areas do not overlap, each is filled with a different opaque color.",
            "The data is plotted as a set of rectangular boxes (one box per series), with the boxes stacked vertically (the base of each box is the top of its predecessor, and the base of the first box is the X axis). Since the boxes do not overlap, each is filled with a different opaque color.",
            "The data is plotted as a heatmap. The series being plotted must have a DISTRIBUTION value type. The value of each bucket in the distribution is displayed as a color. This type is not currently available in the Stackdriver Monitoring application."
          ],
          "enum": [
            "PLOT_TYPE_UNSPECIFIED",
            "LINE",
            "STACKED_AREA",
            "STACKED_BAR",
            "HEATMAP"
          ],
          "description": "How this data should be plotted on the chart."
        },
        "legendTemplate": {
          "description": "A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value.",
          "type": "string"
        }
      },
      "id": "DataSet"
    },
    "SparkChartView": {
      "description": "A sparkChart is a small chart suitable for inclusion in a table-cell or inline in text. This message contains the configuration for a sparkChart to show up on a Scorecard, showing recent trends of the scorecard's timeseries.",
      "type": "object",
      "properties": {
        "minAlignmentPeriod": {
          "type": "string",
          "description": "The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint.",
          "format": "google-duration"
        },
        "sparkChartType": {
          "enum": [
            "SPARK_CHART_TYPE_UNSPECIFIED",
            "SPARK_LINE",
            "SPARK_BAR"
          ],
          "description": "The type of sparkchart to show in this chartView.",
          "type": "string",
          "enumDescriptions": [
            "Not allowed in well-formed requests.",
            "The sparkline will be rendered as a small line chart.",
            "The sparkbar will be rendered as a small bar chart."
          ]
        }
      },
      "id": "SparkChartView"
    },
    "TimeSeriesQuery": {
      "description": "TimeSeriesQuery collects the set of supported methods for querying time series data from the Stackdriver metrics API.",
      "type": "object",
      "properties": {
        "timeSeriesFilterRatio": {
          "$ref": "TimeSeriesFilterRatio",
          "description": "Parameters to fetch a ratio between two time series filters."
        },
        "timeSeriesFilter": {
          "$ref": "TimeSeriesFilter",
          "description": "Filter parameters to fetch time series."
        },
        "unitOverride": {
          "description": "The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit field in MetricDescriptor.",
          "type": "string"
        }
      },
      "id": "TimeSeriesQuery"
    },
    "StatisticalTimeSeriesFilter": {
      "description": "A filter that ranks streams based on their statistical relation to other streams in a request.",
      "type": "object",
      "properties": {
        "rankingMethod": {
          "enum": [
            "METHOD_UNSPECIFIED",
            "METHOD_CLUSTER_OUTLIER"
          ],
          "description": "rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series.",
          "type": "string",
          "enumDescriptions": [
            "Not allowed in well-formed requests.",
            "Compute the outlier score of each stream."
          ]
        },
        "numTimeSeries": {
          "description": "How many time series to output.",
          "format": "int32",
          "type": "integer"
        }
      },
      "id": "StatisticalTimeSeriesFilter"
    },
    "GaugeView": {
      "id": "GaugeView",
      "description": "A gauge chart shows where the current value sits within a pre-defined range. The upper and lower bounds should define the possible range of values for the scorecard's query (inclusive).",
      "type": "object",
      "properties": {
        "upperBound": {
          "description": "The upper bound for this gauge chart. The value of the chart should always be less than or equal to this.",
          "format": "double",
          "type": "number"
        },
        "lowerBound": {
          "description": "The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this.",
          "format": "double",
          "type": "number"
        }
      }
    },
    "Aggregation": {
      "type": "object",
      "properties": {
        "perSeriesAligner": {
          "type": "string",
          "enumDescriptions": [
            "No alignment. Raw data is returned. Not valid if cross-time series reduction is requested. The value type of the result is the same as the value type of the input.",
            "Align and convert to delta metric type. This alignment is valid for cumulative metrics and delta metrics. Aligning an existing delta metric to a delta metric requires that the alignment period be increased. The value type of the result is the same as the value type of the input.One can think of this aligner as a rate but without time units; that is, the output is conceptually (second_point - first_point).",
            "Align and convert to a rate. This alignment is valid for cumulative metrics and delta metrics with numeric values. The output is a gauge metric with value type DOUBLE.One can think of this aligner as conceptually providing the slope of the line that passes through the value at the start and end of the window. In other words, this is conceptually ((y1 - y0)/(t1 - t0)), and the output unit is one that has a \"/time\" dimension.If, by rate, you are looking for percentage change, see the ALIGN_PERCENT_CHANGE aligner option.",
            "Align by interpolating between adjacent points around the period boundary. This alignment is valid for gauge metrics with numeric values. The value type of the result is the same as the value type of the input.",
            "Align by shifting the oldest data point before the period boundary to the boundary. This alignment is valid for gauge metrics. The value type of the result is the same as the value type of the input.",
            "Align time series via aggregation. The resulting data point in the alignment period is the minimum of all data points in the period. This alignment is valid for gauge and delta metrics with numeric values. The value type of the result is the same as the value type of the input.",
            "Align time series via aggregation. The resulting data point in the alignment period is the maximum of all data points in the period. This alignment is valid for gauge and delta metrics with numeric values. The value type of the result is the same as the value type of the input.",
            "Align time series via aggregation. The resulting data point in the alignment period is the average or arithmetic mean of all data points in the period. This alignment is valid for gauge and delta metrics with numeric values. The value type of the output is DOUBLE.",
            "Align time series via aggregation. The resulting data point in the alignment period is the count of all data points in the period. This alignment is valid for gauge and delta metrics with numeric or Boolean values. The value type of the output is INT64.",
            "Align time series via aggregation. The resulting data point in the alignment period is the sum of all data points in the period. This alignment is valid for gauge and delta metrics with numeric and distribution values. The value type of the output is the same as the value type of the input.",
            "Align time series via aggregation. The resulting data point in the alignment period is the standard deviation of all data points in the period. This alignment is valid for gauge and delta metrics with numeric values. The value type of the output is DOUBLE.",
            "Align time series via aggregation. The resulting data point in the alignment period is the count of True-valued data points in the period. This alignment is valid for gauge metrics with Boolean values. The value type of the output is INT64.",
            "Align time series via aggregation. The resulting data point in the alignment period is the count of False-valued data points in the period. This alignment is valid for gauge metrics with Boolean values. The value type of the output is INT64.",
            "Align time series via aggregation. The resulting data point in the alignment period is the fraction of True-valued data points in the period. This alignment is valid for gauge metrics with Boolean values. The output value is in the range 0, 1 and has value type DOUBLE.",
            "Align time series via aggregation. The resulting data point in the alignment period is the 99th percentile of all data points in the period. This alignment is valid for gauge and delta metrics with distribution values. The output is a gauge metric with value type DOUBLE.",
            "Align time series via aggregation. The resulting data point in the alignment period is the 95th percentile of all data points in the period. This alignment is valid for gauge and delta metrics with distribution values. The output is a gauge metric with value type DOUBLE.",
            "Align time series via aggregation. The resulting data point in the alignment period is the 50th percentile of all data points in the period. This alignment is valid for gauge and delta metrics with distribution values. The output is a gauge metric with value type DOUBLE.",
            "Align time series via aggregation. The resulting data point in the alignment period is the 5th percentile of all data points in the period. This alignment is valid for gauge and delta metrics with distribution values. The output is a gauge metric with value type DOUBLE.",
            "Align and convert to a percentage change. This alignment is valid for gauge and delta metrics with numeric values. This alignment conceptually computes the equivalent of \"((current - previous)/previous)*100\" where previous value is determined based on the alignmentPeriod. In the event that previous is 0 the calculated value is infinity with the exception that if both (current - previous) and previous are 0 the calculated value is 0. A 10 minute moving mean is computed at each point of the time window prior to the above calculation to smooth the metric and prevent false positives from very short lived spikes. Only applicable for data that is \u003e= 0. Any values \u003c 0 are treated as no data. While delta metrics are accepted by this alignment special care should be taken that the values for the metric will always be positive. The output is a gauge metric with value type DOUBLE."
          ],
          "enum": [
            "ALIGN_NONE",
            "ALIGN_DELTA",
            "ALIGN_RATE",
            "ALIGN_INTERPOLATE",
            "ALIGN_NEXT_OLDER",
            "ALIGN_MIN",
            "ALIGN_MAX",
            "ALIGN_MEAN",
            "ALIGN_COUNT",
            "ALIGN_SUM",
            "ALIGN_STDDEV",
            "ALIGN_COUNT_TRUE",
            "ALIGN_COUNT_FALSE",
            "ALIGN_FRACTION_TRUE",
            "ALIGN_PERCENTILE_99",
            "ALIGN_PERCENTILE_95",
            "ALIGN_PERCENTILE_50",
            "ALIGN_PERCENTILE_05",
            "ALIGN_PERCENT_CHANGE"
          ],
          "description": "The approach to be used to align individual time series. Not all alignment functions may be applied to all time series, depending on the metric type and value type of the original time series. Alignment may change the metric type or the value type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned."
        },
        "alignmentPeriod": {
          "description": "The alignment period for per-time series alignment. If present, alignmentPeriod must be at least 60 seconds. After per-time series alignment, each time series will contain data points only on the period boundaries. If perSeriesAligner is not specified or equals ALIGN_NONE, then this field is ignored. If perSeriesAligner is specified and does not equal ALIGN_NONE, then this field must be defined; otherwise an error is returned.",
          "format": "google-duration",
          "type": "string"
        },
        "crossSeriesReducer": {
          "enum": [
            "REDUCE_NONE",
            "REDUCE_MEAN",
            "REDUCE_MIN",
            "REDUCE_MAX",
            "REDUCE_SUM",
            "REDUCE_STDDEV",
            "REDUCE_COUNT",
            "REDUCE_COUNT_TRUE",
            "REDUCE_COUNT_FALSE",
            "REDUCE_FRACTION_TRUE",
            "REDUCE_PERCENTILE_99",
            "REDUCE_PERCENTILE_95",
            "REDUCE_PERCENTILE_50",
            "REDUCE_PERCENTILE_05"
          ],
          "description": "The approach to be used to combine time series. Not all reducer functions may be applied to all time series, depending on the metric type and the value type of the original time series. Reduction may change the metric type of value type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If crossSeriesReducer is specified, then perSeriesAligner must be specified and not equal ALIGN_NONE and alignmentPeriod must be specified; otherwise, an error is returned.",
          "type": "string",
          "enumDescriptions": [
            "No cross-time series reduction. The output of the aligner is returned.",
            "Reduce by computing the mean across time series for each alignment period. This reducer is valid for delta and gauge metrics with numeric or distribution values. The value type of the output is DOUBLE.",
            "Reduce by computing the minimum across time series for each alignment period. This reducer is valid for delta and gauge metrics with numeric values. The value type of the output is the same as the value type of the input.",
            "Reduce by computing the maximum across time series for each alignment period. This reducer is valid for delta and gauge metrics with numeric values. The value type of the output is the same as the value type of the input.",
            "Reduce by computing the sum across time series for each alignment period. This reducer is valid for delta and gauge metrics with numeric and distribution values. The value type of the output is the same as the value type of the input.",
            "Reduce by computing the standard deviation across time series for each alignment period. This reducer is valid for delta and gauge metrics with numeric or distribution values. The value type of the output is DOUBLE.",
            "Reduce by computing the count of data points across time series for each alignment period. This reducer is valid for delta and gauge metrics of numeric, Boolean, distribution, and string value type. The value type of the output is INT64.",
            "Reduce by computing the count of True-valued data points across time series for each alignment period. This reducer is valid for delta and gauge metrics of Boolean value type. The value type of the output is INT64.",
            "Reduce by computing the count of False-valued data points across time series for each alignment period. This reducer is valid for delta and gauge metrics of Boolean value type. The value type of the output is INT64.",
            "Reduce by computing the fraction of True-valued data points across time series for each alignment period. This reducer is valid for delta and gauge metrics of Boolean value type. The output value is in the range 0, 1 and has value type DOUBLE.",
            "Reduce by computing 99th percentile of data points across time series for each alignment period. This reducer is valid for gauge and delta metrics of numeric and distribution type. The value of the output is DOUBLE",
            "Reduce by computing 95th percentile of data points across time series for each alignment period. This reducer is valid for gauge and delta metrics of numeric and distribution type. The value of the output is DOUBLE",
            "Reduce by computing 50th percentile of data points across time series for each alignment period. This reducer is valid for gauge and delta metrics of numeric and distribution type. The value of the output is DOUBLE",
            "Reduce by computing 5th percentile of data points across time series for each alignment period. This reducer is valid for gauge and delta metrics of numeric and distribution type. The value of the output is DOUBLE"
          ]
        },
        "groupByFields": {
          "description": "The set of fields to preserve when crossSeriesReducer is specified. The groupByFields determine how the time series are partitioned into subsets prior to applying the aggregation function. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The crossSeriesReducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in groupByFields are aggregated away. If groupByFields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If crossSeriesReducer is not defined, this field is ignored.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "id": "Aggregation",
      "description": "Describes how to combine multiple time series to provide different views of the data. Aggregation consists of an alignment step on individual time series (alignment_period and per_series_aligner) followed by an optional reduction step of the data across the aligned time series (cross_series_reducer and group_by_fields). For more details, see Aggregation."
    },
    "Widget": {
      "id": "Widget",
      "description": "Widget contains a single dashboard component and configuration of how to present the component in the dashboard.",
      "type": "object",
      "properties": {
        "xyChart": {
          "$ref": "XyChart",
          "description": "A chart of time series data."
        },
        "title": {
          "description": "Optional. The title of the widget.",
          "type": "string"
        },
        "scorecard": {
          "description": "A scorecard summarizing time series data.",
          "$ref": "Scorecard"
        },
        "blank": {
          "$ref": "Empty",
          "description": "A blank space."
        },
        "text": {
          "$ref": "Text",
          "description": "A raw string or markdown displaying textual content."
        }
      }
    },
    "TimeSeriesFilter": {
      "description": "A filter that defines a subset of time series data that is displayed in a widget. Time series data is fetched using the ListTimeSeries method.",
      "type": "object",
      "properties": {
        "aggregation": {
          "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data.",
          "$ref": "Aggregation"
        },
        "pickTimeSeriesFilter": {
          "$ref": "PickTimeSeriesFilter",
          "description": "Ranking based time series filter."
        },
        "filter": {
          "type": "string",
          "description": "Required. The monitoring filter that identifies the metric types, resources, and projects to query."
        },
        "statisticalTimeSeriesFilter": {
          "description": "Statistics based time series filter.",
          "$ref": "StatisticalTimeSeriesFilter"
        }
      },
      "id": "TimeSeriesFilter"
    },
    "RatioPart": {
      "type": "object",
      "properties": {
        "aggregation": {
          "$ref": "Aggregation",
          "description": "By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data."
        },
        "filter": {
          "description": "Required. The monitoring filter that identifies the metric types, resources, and projects to query.",
          "type": "string"
        }
      },
      "id": "RatioPart",
      "description": "Describes a query to build the numerator or denominator of a TimeSeriesFilterRatio."
    },
    "Empty": {
      "id": "Empty",
      "description": "A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance:\nservice Foo {\n  rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n}\nThe JSON representation for Empty is empty JSON object {}.",
      "type": "object",
      "properties": {}
    },
    "TimeSeriesFilterRatio": {
      "id": "TimeSeriesFilterRatio",
      "description": "A pair of time series filters that define a ratio computation. The output time series is the pair-wise division of each aligned element from the numerator and denominator time series.",
      "type": "object",
      "properties": {
        "statisticalTimeSeriesFilter": {
          "$ref": "StatisticalTimeSeriesFilter",
          "description": "Statistics based time series filter."
        },
        "numerator": {
          "$ref": "RatioPart",
          "description": "The numerator of the ratio."
        },
        "denominator": {
          "description": "The denominator of the ratio.",
          "$ref": "RatioPart"
        },
        "secondaryAggregation": {
          "$ref": "Aggregation",
          "description": "Apply a second aggregation after the ratio is computed."
        },
        "pickTimeSeriesFilter": {
          "description": "Ranking based time series filter.",
          "$ref": "PickTimeSeriesFilter"
        }
      }
    },
    "Option": {
      "id": "Option",
      "description": "A protocol buffer option, which can be attached to a message, field, enumeration, etc.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The option's name. For protobuf built-in options (options defined in descriptor.proto), this is the short name. For example, \"map_entry\". For custom options, it should be the fully-qualified name. For example, \"google.api.http\".",
          "type": "string"
        },
        "value": {
          "additionalProperties": {
            "description": "Properties of the object. Contains field @type with type URL.",
            "type": "any"
          },
          "description": "The option's value packed in an Any message. If the value is a primitive, the corresponding wrapper type defined in google/protobuf/wrappers.proto should be used. If the value is an enum, it should be stored as an int32 value using the google.protobuf.Int32Value type.",
          "type": "object"
        }
      }
    },
    "ColumnLayout": {
      "id": "ColumnLayout",
      "description": "A simplified layout that divides the available space into vertical columns and arranges a set of widgets vertically in each column.",
      "type": "object",
      "properties": {
        "columns": {
          "description": "The columns of content to display.",
          "type": "array",
          "items": {
            "$ref": "Column"
          }
        }
      }
    },
    "Dashboard": {
      "type": "object",
      "properties": {
        "etag": {
          "type": "string",
          "description": "etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation."
        },
        "columnLayout": {
          "$ref": "ColumnLayout",
          "description": "The content is divided into equally spaced columns and the widgets are arranged vertically."
        },
        "name": {
          "description": "The resource name of the dashboard.",
          "type": "string"
        },
        "gridLayout": {
          "$ref": "GridLayout",
          "description": "Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles."
        },
        "rowLayout": {
          "$ref": "RowLayout",
          "description": "The content is divided into equally spaced rows and the widgets are arranged horizontally."
        },
        "displayName": {
          "description": "The mutable, human-readable name.",
          "type": "string"
        }
      },
      "id": "Dashboard",
      "description": "A Google Stackdriver dashboard. Dashboards define the content and layout of pages in the Stackdriver web application."
    },
    "Axis": {
      "description": "A chart axis.",
      "type": "object",
      "properties": {
        "label": {
          "description": "The label of the axis.",
          "type": "string"
        },
        "scale": {
          "description": "The axis scale. By default, a linear scale is used.",
          "type": "string",
          "enumDescriptions": [
            "Scale is unspecified. The view will default to LINEAR.",
            "Linear scale.",
            "Logarithmic scale (base 10)."
          ],
          "enum": [
            "SCALE_UNSPECIFIED",
            "LINEAR",
            "LOG10"
          ]
        }
      },
      "id": "Axis"
    },
    "ListDashboardsResponse": {
      "description": "The ListDashboards request.",
      "type": "object",
      "properties": {
        "dashboards": {
          "description": "The list of requested dashboards.",
          "type": "array",
          "items": {
            "$ref": "Dashboard"
          }
        },
        "nextPageToken": {
          "description": "If there are more results than have been returned, then this field is set to a non-empty value. To see the additional results, use that value as pageToken in the next call to this method.",
          "type": "string"
        }
      },
      "id": "ListDashboardsResponse"
    },
    "Field": {
      "description": "A single field of a message type.",
      "type": "object",
      "properties": {
        "number": {
          "type": "integer",
          "description": "The field number.",
          "format": "int32"
        },
        "kind": {
          "type": "string",
          "enumDescriptions": [
            "Field type unknown.",
            "Field type double.",
            "Field type float.",
            "Field type int64.",
            "Field type uint64.",
            "Field type int32.",
            "Field type fixed64.",
            "Field type fixed32.",
            "Field type bool.",
            "Field type string.",
            "Field type group. Proto2 syntax only, and deprecated.",
            "Field type message.",
            "Field type bytes.",
            "Field type uint32.",
            "Field type enum.",
            "Field type sfixed32.",
            "Field type sfixed64.",
            "Field type sint32.",
            "Field type sint64."
          ],
          "enum": [
            "TYPE_UNKNOWN",
            "TYPE_DOUBLE",
            "TYPE_FLOAT",
            "TYPE_INT64",
            "TYPE_UINT64",
            "TYPE_INT32",
            "TYPE_FIXED64",
            "TYPE_FIXED32",
            "TYPE_BOOL",
            "TYPE_STRING",
            "TYPE_GROUP",
            "TYPE_MESSAGE",
            "TYPE_BYTES",
            "TYPE_UINT32",
            "TYPE_ENUM",
            "TYPE_SFIXED32",
            "TYPE_SFIXED64",
            "TYPE_SINT32",
            "TYPE_SINT64"
          ],
          "description": "The field type."
        },
        "jsonName": {
          "description": "The field JSON name.",
          "type": "string"
        },
        "options": {
          "type": "array",
          "items": {
            "$ref": "Option"
          },
          "description": "The protocol buffer options."
        },
        "oneofIndex": {
          "type": "integer",
          "description": "The index of the field type in Type.oneofs, for message or enumeration types. The first type has index 1; zero means the type is not in the list.",
          "format": "int32"
        },
        "packed": {
          "description": "Whether to use alternative packed wire representation.",
          "type": "boolean"
        },
        "cardinality": {
          "description": "The field cardinality.",
          "type": "string",
          "enumDescriptions": [
            "For fields with unknown cardinality.",
            "For optional fields.",
            "For required fields. Proto2 syntax only.",
            "For repeated fields."
          ],
          "enum": [
            "CARDINALITY_UNKNOWN",
            "CARDINALITY_OPTIONAL",
            "CARDINALITY_REQUIRED",
            "CARDINALITY_REPEATED"
          ]
        },
        "defaultValue": {
          "type": "string",
          "description": "The string value of the default value of this field. Proto2 syntax only."
        },
        "name": {
          "description": "The field name.",
          "type": "string"
        },
        "typeUrl": {
          "description": "The field type URL, without the scheme, for message or enumeration types. Example: \"type.googleapis.com/google.protobuf.Timestamp\".",
          "type": "string"
        }
      },
      "id": "Field"
    },
    "Scorecard": {
      "type": "object",
      "properties": {
        "timeSeriesQuery": {
          "$ref": "TimeSeriesQuery",
          "description": "Fields for querying time series data from the Stackdriver metrics API."
        },
        "sparkChartView": {
          "$ref": "SparkChartView",
          "description": "Will cause the scorecard to show a spark chart."
        },
        "thresholds": {
          "description": "The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: {  value: 90,  category: 'DANGER',  trigger: 'ABOVE', }, {  value: 70,  category: 'WARNING',  trigger: 'ABOVE', }, {  value: 10,  category: 'DANGER',  trigger: 'BELOW', }, {  value: 20,  category: 'WARNING',  trigger: 'BELOW', }Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state.",
          "type": "array",
          "items": {
            "$ref": "Threshold"
          }
        },
        "gaugeView": {
          "$ref": "GaugeView",
          "description": "Will cause the scorecard to show a gauge chart."
        }
      },
      "id": "Scorecard",
      "description": "A widget showing the latest value of a metric, and how this value relates to one or more thresholds."
    }
  },
  "icons": {
    "x16": "http://www.google.com/images/icons/product/search-16.gif",
    "x32": "http://www.google.com/images/icons/product/search-32.gif"
  },
  "protocol": "rest",
  "canonicalName": "Monitoring",
  "auth": {
    "oauth2": {
      "scopes": {
        "https://www.googleapis.com/auth/monitoring": {
          "description": "View and write monitoring data for all of your Google and third-party Cloud and API projects"
        },
        "https://www.googleapis.com/auth/monitoring.write": {
          "description": "Publish metric data to your Google Cloud projects"
        },
        "https://www.googleapis.com/auth/cloud-platform": {
          "description": "View and manage your data across Google Cloud Platform services"
        },
        "https://www.googleapis.com/auth/monitoring.read": {
          "description": "View monitoring data for all of your Google Cloud and third-party projects"
        }
      }
    }
  },
  "rootUrl": "https://monitoring.googleapis.com/",
  "ownerDomain": "google.com",
  "name": "monitoring",
  "batchPath": "batch",
  "fullyEncodeReservedExpansion": true,
  "title": "Stackdriver Monitoring API",
  "ownerName": "Google",
  "resources": {
    "projects": {
      "resources": {
        "dashboards": {
          "methods": {
            "delete": {
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/monitoring",
                "https://www.googleapis.com/auth/monitoring.write"
              ],
              "parameters": {
                "name": {
                  "pattern": "^projects/[^/]+/dashboards/[^/]+$",
                  "location": "path",
                  "description": "The resource name of the Dashboard. The format is \"projects/{project_id_or_number}/dashboards/{dashboard_id}\".",
                  "required": true,
                  "type": "string"
                }
              },
              "flatPath": "v1/projects/{projectsId}/dashboards/{dashboardsId}",
              "path": "v1/{+name}",
              "id": "monitoring.projects.dashboards.delete",
              "description": "Deletes an existing custom dashboard.This method requires the monitoring.dashboards.delete permission on the specified dashboard. For more information, see Google Cloud IAM (https://cloud.google.com/iam).",
              "response": {
                "$ref": "Empty"
              },
              "parameterOrder": [
                "name"
              ],
              "httpMethod": "DELETE"
            },
            "list": {
              "response": {
                "$ref": "ListDashboardsResponse"
              },
              "parameterOrder": [
                "parent"
              ],
              "httpMethod": "GET",
              "parameters": {
                "pageToken": {
                  "location": "query",
                  "description": "If this field is not empty then it must contain the nextPageToken value returned by a previous call to this method. Using this field causes the method to return additional results from the previous method call.",
                  "type": "string"
                },
                "pageSize": {
                  "location": "query",
                  "description": "A positive number that is the maximum number of results to return. If unspecified, a default of 1000 is used.",
                  "format": "int32",
                  "type": "integer"
                },
                "parent": {
                  "location": "path",
                  "description": "The scope of the dashboards to list. A project scope must be specified in the form of \"projects/{project_id_or_number}\".",
                  "required": true,
                  "type": "string",
                  "pattern": "^projects/[^/]+$"
                }
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/monitoring",
                "https://www.googleapis.com/auth/monitoring.read"
              ],
              "flatPath": "v1/projects/{projectsId}/dashboards",
              "path": "v1/{+parent}/dashboards",
              "id": "monitoring.projects.dashboards.list",
              "description": "Lists the existing dashboards.This method requires the monitoring.dashboards.list permission on the specified project. For more information, see Google Cloud IAM (https://cloud.google.com/iam)."
            },
            "get": {
              "path": "v1/{+name}",
              "id": "monitoring.projects.dashboards.get",
              "description": "Fetches a specific dashboard.This method requires the monitoring.dashboards.get permission on the specified dashboard. For more information, see Google Cloud IAM (https://cloud.google.com/iam).",
              "response": {
                "$ref": "Dashboard"
              },
              "parameterOrder": [
                "name"
              ],
              "httpMethod": "GET",
              "parameters": {
                "name": {
                  "location": "path",
                  "description": "The resource name of the Dashboard. The format is one of \"dashboards/{dashboard_id}\" (for system dashboards) or \"projects/{project_id_or_number}/dashboards/{dashboard_id}\" (for custom dashboards).",
                  "required": true,
                  "type": "string",
                  "pattern": "^projects/[^/]+/dashboards/[^/]+$"
                }
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/monitoring",
                "https://www.googleapis.com/auth/monitoring.read"
              ],
              "flatPath": "v1/projects/{projectsId}/dashboards/{dashboardsId}"
            },
            "patch": {
              "parameters": {
                "name": {
                  "pattern": "^projects/[^/]+/dashboards/[^/]+$",
                  "location": "path",
                  "description": "The resource name of the dashboard.",
                  "required": true,
                  "type": "string"
                }
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/monitoring",
                "https://www.googleapis.com/auth/monitoring.write"
              ],
              "flatPath": "v1/projects/{projectsId}/dashboards/{dashboardsId}",
              "id": "monitoring.projects.dashboards.patch",
              "path": "v1/{+name}",
              "description": "Replaces an existing custom dashboard with a new definition.This method requires the monitoring.dashboards.update permission on the specified dashboard. For more information, see Google Cloud IAM (https://cloud.google.com/iam).",
              "request": {
                "$ref": "Dashboard"
              },
              "httpMethod": "PATCH",
              "parameterOrder": [
                "name"
              ],
              "response": {
                "$ref": "Dashboard"
              }
            },
            "create": {
              "request": {
                "$ref": "Dashboard"
              },
              "description": "Creates a new custom dashboard.This method requires the monitoring.dashboards.create permission on the specified project. For more information, see Google Cloud IAM (https://cloud.google.com/iam).",
              "response": {
                "$ref": "Dashboard"
              },
              "parameterOrder": [
                "parent"
              ],
              "httpMethod": "POST",
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/monitoring",
                "https://www.googleapis.com/auth/monitoring.write"
              ],
              "parameters": {
                "parent": {
                  "location": "path",
                  "description": "The project on which to execute the request. The format is \"projects/{project_id_or_number}\". The {project_id_or_number} must match the dashboard resource name.",
                  "required": true,
                  "type": "string",
                  "pattern": "^projects/[^/]+$"
                }
              },
              "flatPath": "v1/projects/{projectsId}/dashboards",
              "path": "v1/{+parent}/dashboards",
              "id": "monitoring.projects.dashboards.create"
            }
          }
        }
      }
    }
  },
  "parameters": {
    "access_token": {
      "description": "OAuth access token.",
      "type": "string",
      "location": "query"
    },
    "key": {
      "type": "string",
      "location": "query",
      "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token."
    },
    "upload_protocol": {
      "description": "Upload protocol for media (e.g. \"raw\", \"multipart\").",
      "type": "string",
      "location": "query"
    },
    "quotaUser": {
      "location": "query",
      "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.",
      "type": "string"
    },
    "prettyPrint": {
      "type": "boolean",
      "default": "true",
      "location": "query",
      "description": "Returns response with indentations and line breaks."
    },
    "fields": {
      "description": "Selector specifying which fields to include in a partial response.",
      "type": "string",
      "location": "query"
    },
    "uploadType": {
      "type": "string",
      "location": "query",
      "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\")."
    },
    "callback": {
      "location": "query",
      "description": "JSONP",
      "type": "string"
    },
    "oauth_token": {
      "description": "OAuth 2.0 token for the current user.",
      "type": "string",
      "location": "query"
    },
    "$.xgafv": {
      "enumDescriptions": [
        "v1 error format",
        "v2 error format"
      ],
      "location": "query",
      "enum": [
        "1",
        "2"
      ],
      "description": "V1 error format.",
      "type": "string"
    },
    "alt": {
      "type": "string",
      "enumDescriptions": [
        "Responses with Content-Type of application/json",
        "Media download with context-dependent Content-Type",
        "Responses with Content-Type of application/x-protobuf"
      ],
      "location": "query",
      "description": "Data format for response.",
      "default": "json",
      "enum": [
        "json",
        "media",
        "proto"
      ]
    }
  }
}
